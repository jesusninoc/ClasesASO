# Administración de servicio de directorio
- Servicio de directorio. Definición, elementos y nomenclatura. LDAP.
- Esquema del servicio de directorio.
- Funciones del dominio
- Controladores de dominio.
- Instalación, configuración y personalización del servicio de directorio.
- Creación de dominios.
- Objetos que administra un dominio: usuarios globales, grupos y equipos entre otros.
- Herramientas gráficas de administración del servicio de directorio.
- Filtros de búsqueda.
- Integración del servicio de directorio con otros servicios.
- Relaciones de confianza. 

# Aplicación de lenguajes de «scripting» en sistemas operativos libres y propietarios:
- Estructuras del lenguaje.
- Creación y depuración de «scripts».
- Interpretación de «scripts» del sistema. Adaptaciones.
- Utilización de extensiones de comandos para tareas de administración.
- «Scripts» para la gestión del directorio activo. Usuarios, grupos, acceso al registro, etc.
- «Scripts» para la administración de cuentas de usuario, procesos y servicios del sistema operativo. 

# Práctica del tema: crear un formulario que permita introducir nombres y operación (crear usuario, grupo, OU, etc.) al departamento de Recursos Humanos, cada vez que se introduce un usuario se añade a un fichero JSON que se sube a un servidor web, por otro lado, desarrollar un script que lea ese fichero JSON desde una URL y realice las operaciones que están indicadas (crear usuario, grupo, OU, etc.) además para cada usuario crear un código QR
* https://www.jesusninoc.com/09/23/ejercicios-de-powershell-crear-un-interfaz-grafico-que-cree-objetos-de-tipo-alumno-crear-la-clase-alumno-con-nombre-y-los-anada-a-un-fichero-json/
* https://www.jesusninoc.com/02/25/crear-un-formulario-con-un-boton-en-powershell/
* https://www.jesusninoc.com/03/03/crear-formularios-parte-3/#Formulario_2
* https://www.jesusninoc.com/09/23/crear-una-clase-operaciones-con-sus-propiedades-despues-crear-objetos-de-esa-clase-anadirlos-a-un-arraylist-convertirlos-en-formato-json-y-almacenarlos-en-un-fichero/
* https://www.jesusninoc.com/06/07/como-funciona-un-servidor-web-explicado-desde-powershell/
* https://www.jesusninoc.com/05/10/ejercicios-de-powershell-leer-operaciones-de-un-fichero-y-realizarlas/
* https://www.jesusninoc.com/06/01/crear-y-leer-un-codigo-qr-con-un-comando-en-bash-mediante-wsl-desde-powershell/

--------
--------

# Administración de procesos del sistema
- Procesos. Tipos. Estados. Estructura.
- Hilos de ejecución.
- Transiciones de estados.
- Prioridades.
- Identificación de los procesos del sistema.
- Gestión de los procesos del sistema. Línea de orden. Entorno gráfico.
- Secuencia de arranque del sistema. Demonios.
- Niveles de ejecución del sistema. Cambio.
- Interrupciones. Excepciones.

------------------

# Administración de procesos del sistema
## Ejercicios de procesos algoritmos, programando los algoritmos
* https://www.jesusninoc.com/07/07/7-gestion-de-procesos-en-powershell/#Informacion_sobre_procesos

# Ejercicios
## Hacer el hash de cada uno de los módulos que ejecuta el proceso Notepad
```PowerShell
# Hash
    # Get-FileHash
# Módulos
    # Get-Process -Module
# Proceso Notepad
    # Get-Process -Name notepad

foreach ($modulo in (Get-Process -Name notepad -Module | select FileName))
{
    Get-FileHash $modulo.FileName
}
```

# Si encuentras el siguiente hash "AAE0D838848764E810862A2F038FB4737685AE9510D9BABB9C97052B955CA501" dentro de los hashes que han generado los módulos que ejecuta el proceso Notepad mostrar un mensaje de "Hash encontrado"
```PowerShell
# Where
    # (Get-Process).Where{$_.Name -like "chrome"}
# IF
    # if($var -eq "algo"){"Es algo"}

# Mensaje
    # [System.Windows.MessageBox]::Show('Sí o No','Mensaje','YesNo','Warning')

    # Notificación https://www.jesusninoc.com/11/23/crear-una-notificacion-en-windows-con-powershell/

foreach ($modulo in (Get-Process -Name notepad -Module | select FileName))
{
    if ((Get-FileHash $modulo.FileName).hash -eq "AAE0D838848764E810862A2F038FB4737685AE9510D9BABB9C97052B955CA501")
    {
        [System.Windows.MessageBox]::Show('Hash encontrado','Warning')
        $balloon = New-Object System.Windows.Forms.NotifyIcon 

        #Configurar notificación
        #Icono
        $balloon.Icon  = [System.Drawing.Icon]::ExtractAssociatedIcon((Get-Process -Name notepad).Path) 
        $balloon.BalloonTipIcon  = [string]$Icon = 'Info'
        #Mensaje
        $balloon.BalloonTipText  = "Mensaje"
        #Título
        $balloon.BalloonTipTitle  = "Hash encontrado"+$modulo.FileName
 
        $balloon.Visible  = $true
        $balloon.ShowBalloonTip(5000)
    }
}
```

---------------
---------------

# Administración de procesos del sistema
- Procesos. Tipos. Estados. Estructura.
- Hilos de ejecución.
- Transiciones de estados.
- Prioridades.
- Identificación de los procesos del sistema.
- Gestión de los procesos del sistema. Línea de orden. Entorno gráfico.
- Secuencia de arranque del sistema. Demonios.
- Niveles de ejecución del sistema. Cambio.
- Interrupciones. Excepciones.

------------------

# Administración de procesos del sistema
* https://www.jesusninoc.com/07/07/7-gestion-de-procesos-en-powershell/

# Ejercicios
## Saber el tiempo que lleva alguien en Facebook
```PowerShell
Get-Process | Select-Object name,Id,TotalProcessorTime

Get-WmiObject win32_process | select commandline | Format-Custom

$Proceso=Get-Process -Name notepad
$NombreF=(($Proceso).name)+'.dmp'
$Fichero = New-Object IO.FileStream($NombreF,[IO.FileMode]::Create)
(([PSObject].Assembly.GetType('System.Management.Automation.WindowsErrorReporting')).GetNestedType('NativeMethods', 'NonPublic')).GetMethod('MiniDumpWriteDump',[Reflection.BindingFlags] 'NonPublic, Static').Invoke($null, @($Proceso.Handle,$Proceso.Id,$Fichero.SafeFileHandle,[UInt32] 2,[IntPtr]::Zero,[IntPtr]::Zero,[IntPtr]::Zero))
$Fichero.Close()
```
## Utilizar dos cmdlets a la vez para conocer qué proceso padre crea a otro proceso hijo
```PowerShell
Get-WmiObject win32_process | Select-Object name,ParentProcessId,ProcessId

Get-WmiObject win32_process | %{
    "Al proceso " + $_.name + " le ejecuta el proceso " + (Get-Process -id  $_.ParentProcessId).Name
}
```
## Mostrar un mensaje emergente cuando la carga del procesador supera 10

### Carga del procesador
```PowerShell
Get-WmiObject Win32_Processor | select LoadPercentage
```
### Crear un mensaje emergente
```PowerShell
[System.Windows.MessageBox]::Show('Hash encontrado','Warning')
$balloon = New-Object System.Windows.Forms.NotifyIcon 

#Configurar notificación
#Icono
$balloon.Icon  = [System.Drawing.Icon]::ExtractAssociatedIcon((Get-Process -Name notepad).Path) 
$balloon.BalloonTipIcon  = [string]$Icon = 'Info'
#Mensaje
$balloon.BalloonTipText  = "Mensaje"
#Título
$balloon.BalloonTipTitle  = "Hash encontrado"+$modulo.FileName
 
$balloon.Visible  = $true
$balloon.ShowBalloonTip(5000)
```
### Crear el código que muestra mensaje si supera el consumo
```PowerShell
$carga = Get-WmiObject Win32_Processor | select LoadPercentage
if($carga.LoadPercentage -gt 5)
{
    [System.Windows.MessageBox]::Show('Carga en exceso','Warning')

    $balloon = New-Object System.Windows.Forms.NotifyIcon
    #Configurar notificación
    #Icono
    $balloon.Icon  = [System.Drawing.Icon]::ExtractAssociatedIcon((Get-Process -Name notepad).Path) 
    $balloon.BalloonTipIcon  = [string]$Icon = 'Info'
    #Mensaje
    $balloon.BalloonTipText  = "Mensaje"
    #Título
    $balloon.BalloonTipTitle  = "Carga en exceso"+$carga.LoadPercentage
 
    $balloon.Visible  = $true
    $balloon.ShowBalloonTip(5000)
}
```
## REGISTRAR UN EVENTO Y MOSTRAR UN MENSAJE EMERGENTE EN POWERSHELL CUANDO SE EJECUTA UN PROGRAMA

### REGISTRAR UN EVENTO Y MOSTRAR UN MENSAJE EN POWERSHELL CUANDO SE EJECUTA UN PROGRAMA
```PowerShell
while(1)
{
Get-Event | Remove-Event -ErrorAction SilentlyContinue
#Registrar el evento de ejecutar notepad
Register-WmiEvent -Query "SELECT * FROM Win32_ProcessStartTrace WHERE ProcessName='notepad.exe'"
Wait-Event -OutVariable Event | Out-Null
$Event.sourceargs.newevent | select-Object ProcessName,TIME_CREATED
}
```
### Crear un mensaje emergente
```PowerShell
[System.Windows.MessageBox]::Show('Hash encontrado','Warning')
$balloon = New-Object System.Windows.Forms.NotifyIcon 

#Configurar notificación
#Icono
$balloon.Icon  = [System.Drawing.Icon]::ExtractAssociatedIcon((Get-Process -Name notepad).Path) 
$balloon.BalloonTipIcon  = [string]$Icon = 'Info'
#Mensaje
$balloon.BalloonTipText  = "Mensaje"
#Título
$balloon.BalloonTipTitle  = "Hash encontrado"+$modulo.FileName
 
$balloon.Visible  = $true
$balloon.ShowBalloonTip(5000)
```

### Compartir datos utilizando la memoria en Linux
* https://www.jesusninoc.com/06/25/utilizar-zonas-de-memoria-compartida-en-linux-mediante-wsl-desde-powershell/

-----------
-----------

# Administración de procesos del sistema
- Procesos. Tipos. Estados. Estructura.
- Hilos de ejecución.
- Transiciones de estados.
- Prioridades.
- Identificación de los procesos del sistema.
- Gestión de los procesos del sistema. Línea de orden. Entorno gráfico.
- Secuencia de arranque del sistema. Demonios.
- Niveles de ejecución del sistema. Cambio.
- Interrupciones. Excepciones.

------------------

# Administración de procesos del sistema
## Ejercicios de procesos algoritmos, programando los algoritmos
* https://www.jesusninoc.com/07/07/7-gestion-de-procesos-en-powershell/
* https://www.jesusninoc.com/07/10/10-gestion-del-rendimiento-en-powershell/
* http://www.developandsys.es/category/windows-server/procesos-wserver/
* http://www.developandsys.es/procesos-userver/
## Hilos
* https://github.com/jesusninoc/ClasesISO/blob/master/2019-10-01.md#ejercicios-sobre-hilos

------------------
# Ejercicios sobre hilos

```PowerShell
# Mostrar threads
(Get-Process | select name,Threads).Threads.id

# Nombre del proceso que tiene un identificador
Get-Process -id 5708

# No funciona porque no se puede enlazar el parámetro Id con processhandle
Get-WmiObject -Class Win32_Thread | select handle,processhandle,(Get-Process -id processhandle)

# Listar hilos de cada proceso
# Relación entre procesos e hilos
# Mostrar los hilos de cada proceso utilizando WMI y el cmdlet Get-Process
Get-WmiObject Win32_Thread | %{
    $_.Handle,$_.ProcessHandle,(Get-Process -Id $_.ProcessHandle).ProcessName
}

# Mostrar información sobre los hilos de todos los procesos que se están ejecutando (qué proceso ejecuta el hilo)
# Relación entre procesos e hilos (otro método) (HILOS -> PROCESOS)
Get-WmiObject -Class Win32_Thread | select handle,processhandle, @{Name="Name Process"; Expression = {((Get-Process -Id $_.processhandle).name)}}

# Mostrar los hilos del proceso Notepad (PROCESOS -> HILOS)
Get-Process -name notepad | select Name,Threads

(Get-WmiObject -Class Win32_Thread -Filter "ProcessHandle = $((gps -name notepad).id)") | %{
    $_.Handle, $_.ProcessHandle, (Get-Process -Id $_.ProcessHandle).ProcessName
}

# Mostrar todos los hilos que ejecutan los procesos (PROCESOS -> HILOS)
Get-Process | select Name,Threads | %{
    $_.Name,($_.Threads).id
}

# Almacenar en un fichero los nombres de los procesos y el número de hilos que tienen
Get-Process | select Name,Threads | %{
    $_.Name + "->" + ($_.Threads).id.count | Out-File monitorizar.txt -Append
}

# Almacenar en un fichero los nombres de los procesos y el número de hilos que tienen (de forma continuada)
for(1)
{
    Get-Process | select Name,Threads | %{
        $_.Name + "->" + ($_.Threads).id.count | Out-File monitorizar.txt -Append
    }
    Start-Sleep -Seconds 10
}

# Almacenar en un fichero los nombres de los procesos y el número de hilos que tienen (de forma continuada junto con la fecha)
for(1)
{
    "----------------------------------------------" | Out-File monitorizar.txt -Append
    Get-Date | Out-File monitorizar.txt -Append
    Get-Process | select Name,Threads | %{
        $_.Name + "->" + ($_.Threads).id.count | Out-File monitorizar.txt -Append
    }
    Start-Sleep -Seconds 10
}

# Almacenar en un fichero los nombres de los procesos y el número de hilos que tienen mediante una función (de forma continuada junto con la fecha)
function contarhilos($Threads)
{
    $Threads.count
}

for(1)
{
    "----------------------------------------------" | Out-File monitorizar.txt -Append
    Get-Date | Out-File monitorizar.txt -Append
    Get-Process | select Name,Threads | %{
        $_.Name + "->" + (contarhilos($_.Threads)) | Out-File monitorizar.txt -Append
    }
    Start-Sleep -Seconds 10
}
```

----------
----------

# Administración de procesos del sistema
- Procesos. Tipos. Estados. Estructura.
- Hilos de ejecución.
- Transiciones de estados.
- Prioridades.
- Identificación de los procesos del sistema.
- Gestión de los procesos del sistema. Línea de orden. Entorno gráfico.
- Secuencia de arranque del sistema. Demonios.
- Niveles de ejecución del sistema. Cambio.
- Interrupciones. Excepciones.

------------------

# Examen mes de octubre (analizar hilos de los procesos en Linux y PowerShell)

## Linux (analizar hilos de los procesos leyendo de un fichero el nombre del proceso)
### Comandos para ver hilos
```Bash
ps -T -p <pid>
ps -To pid,tid,tgid,tty,time,comm -p <pid>
```
### Enlaces
* https://bencane.com/2011/06/25/checking-the-number-of-lwp-threads-in-linux/
* https://unix.stackexchange.com/questions/102951/why-do-top-and-ps-show-different-pids-for-the-same-processes
* http://www.itsprings.co.in/question/What-is-NLWP-in-Linux

### Introducción
```Bash
ejecuta=`echo "ps -T -p ,nano" | cut -d "," -f1`
name=`echo "ps -T -p ,nano" | cut -d "," -f2`
id=`pidof $name`
$ejecuta$id
```

### Solución
```Bash
while read linea
do
    ejecuta=`echo $linea | cut -d "," -f1`
    name=`echo $linea | cut -d "," -f2`
    id=`pidof $name`
    $ejecuta$id
done < fichero
```

## PowerShell

### Solución 0 (leer el nombre del proceso de un fichero y mostrar los hilos)
```PowerShell
$ejecutar = "get-process -name @ notepad" 
"("+$ejecutar.Split("@")[0]+$ejecutar.Split("@")[1]+").threads" | iex
```

### Solución 1
* https://www.jesusninoc.com/02/06/analizar-hilos-con-powershell/

### Solución 2
```PowerShell
# Listar identificadores de hilos
(Get-Process -name notepad | select threads).threads.id

# Listar información de un hilo en concreto
Get-WmiObject -Class win32_thread -Filter "Handle = 6248" | Out-File

# Sirve para analizar la información de hilos en función del proceso que los crea (Notepad)
(Get-Process -name notepad).id
$var=(Get-Process -name notepad).id
Get-WmiObject -Class win32_thread -Filter "ProcessHandle = $var"

# (Leyenda) Sirve para analizar información de hilos en función de los identificadores de cada hilo del proceso que los crea (Notepad)
$var=(Get-Process -name notepad | select threads).threads.id
$var | %{$_}
Get-WmiObject -Class win32_thread -Filter "ProcessHandle = $var"
$var | %{Get-WmiObject -Class win32_thread -Filter "Handle = $_"}
```

### Solución 3
```PowerShell
#Mostrar el proceso que creó el hilo
Get-WmiObject -Class Win32_Thread | %{
    if((Get-Process -Id $_.ProcessHandle).name -eq "notepad")
    {
        write-host $_.ProcessHandle,$_.handle
        Get-Process -Id $_.ProcessHandle | select name,id
    }
}
```

--------------
--------------

# Administración de procesos del sistema
- Procesos. Tipos. Estados. Estructura.
- Hilos de ejecución.
- Transiciones de estados.
- Prioridades.
- Identificación de los procesos del sistema.
- Gestión de los procesos del sistema. Línea de orden. Entorno gráfico.
- Secuencia de arranque del sistema. Demonios.
- Niveles de ejecución del sistema. Cambio.
- Interrupciones. Excepciones.

------------------

# Administración de procesos del sistema
## Ejercicios de procesos algoritmos, programando los algoritmos
* https://www.jesusninoc.com/07/07/7-gestion-de-procesos-en-powershell/
* https://www.jesusninoc.com/07/10/10-gestion-del-rendimiento-en-powershell/
* http://www.developandsys.es/category/windows-server/procesos-wserver/
* http://www.developandsys.es/procesos-userver/
## Servicios
* https://www.jesusninoc.com/10/11/mostrar-la-relacion-entre-servicios-y-procesos-con-powershell/
* https://www.jesusninoc.com/11/10/analizar-servicios-con-powershell/
## Niveles de ejecución
* https://github.com/jesusninoc/ClasesISO/blob/master/2018-01-23.md
* http://www.developandsys.es/procesos-userver/
## Sockets
* https://www.jesusninoc.com/07/09/9-gestion-de-la-red-en-powershell/#TCP
* https://www.jesusninoc.com/07/09/9-gestion-de-la-red-en-powershell/#UDP

------------------

# Ejercicios propuestos
- Procesos y ruta de ejecución del proceso
- Relación entre servicios y procesos
- Relación WMI con procesos
- Relación WMI con servicios
- Relación de servicios con procesos e hilos junto con la ruta de ejecución del programa
```PowerShell
(Get-WmiObject -Class Win32_Service | Where-Object State -EQ ‘Running’) | %{
Write-Host $_.Name,$_.ProcessId,$_.State,(Get-Process -Id $_.ProcessId).Name,(Get-WmiObject -Class Win32_Thread | Where-Object ProcessHandle -EQ $_.ProcessId).handle,(Get-WmiObject -Class win32_process | Where-Object ProcessId -EQ $_.ProcessId | select name, Path, ExecutablePath, CommandLine)
Start-Sleep -Seconds 1
}
```
- Relación entre procesos y puertos TCP abiertos o no
```PowerShell
Get-NetTCPConnection | %{
    Write-Host $_.OwningProcess, (Get-Process -id $_.OwningProcess).name,$_.LocalAddress,$_.LocalPort,$_.RemoteAddress,$_.RemotePort
}
```
- Relación entre procesos y puertos UDP abiertos o no
```PowerShell
Get-NetUDPEndpoint | %{
    Write-Host $_.OwningProcess, (Get-Process -id $_.OwningProcess).name,$_.LocalAddress,$_.LocalPort
}
```
- Crear servicio
https://www.jesusninoc.com/2017/10/17/crear-un-servicio-en-windows-con-powershell/

```PowerShell
New-Service -Name "Tes2" -BinaryPathName '"C:\Program Files\MySQL\MySQL Server 5.1\bin\mysqld" --defaults-file="C:\Program Files\MySQL\MySQL Server 5.1\my.ini" MySQL'

Start-Service tes2
Stop-Service tes2
```
------------------

# Ejercicios avanzados
## Controlling Processor Affinity
* https://community.idera.com/database-tools/powershell/powertips/b/tips/posts/controlling-processor-affinity
```PowerShell
$process = Get-Process -Name notepad
[Convert]::ToString([int]$process.ProcessorAffinity, 2) 

# calculate the bit mask
$mask = '01'
$bits = [Convert]::ToInt32($mask, 2)

# assign new affinity to current PowerShell process
$process = Get-Process -Name notepad
$process.ProcessorAffinity = $bits
```
## Finding Hidden PowerShell Applications
* https://community.idera.com/database-tools/powershell/powertips/b/tips/posts/finding-hidden-powershell-applications
## Validar credenciales de Active Directory 
* https://community.idera.com/database-tools/powershell/powertips/b/tips/posts/validating-active-directory-credentials
## Accepting Masked Passwords
* https://community.idera.com/database-tools/powershell/powertips/b/tips/posts/accepting-masked-passwords
## Validar credenciales de AD y ejecutar un programa si son correctos
```PowerShell
function Login
{
    param
    (
        [Parameter(Mandatory)]
        [SecureString]
        $SafeInput
    )

    $PlainText = [Management.Automation.PSCredential]::new('x',$SafeInput).GetNetworkCredential().Password

    "User entered "

    Add-Type -AssemblyName System.DirectoryServices.AccountManagement
    $account = New-Object System.DirectoryServices.AccountManagement.PrincipalContext([DirectoryServices.AccountManagement.ContextType]::Domain, $env:userdomain)

    if($account.ValidateCredentials('perry', $PlainText)){
    Start-Process notepad
    }
    else
    {
        "No puedes ejecutar Notepad"
    }
}

Login
```
## Detecting Key Press
* https://community.idera.com/database-tools/powershell/powertips/b/tips/posts/detecting-key-press-1
