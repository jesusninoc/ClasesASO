# Scripting
- Curso acelerado de PowerShell https://www.jesusninoc.com/11/22/curso-online-de-powershell-diciembre-2025/
- Cron y tarea programada.
- Automatización
```PowerShell
# 1) Lista los 5 procesos que más CPU consumen
Get-Process |
    Sort-Object CPU -Descending |
    Select-Object -First 5 Id, ProcessName, CPU

# 2) Reinicia el servicio "Spooler" si está detenido
$servicio = Get-Service "Spooler"
if ($servicio.Status -eq "Stopped") {
    Start-Service "Spooler"
    $resultado = "El servicio Spooler estaba detenido y se ha iniciado."
} else {
    $resultado = "El servicio Spooler ya estaba iniciado."
}

# 3) Guarda la fecha y el resultado en un archivo de log
$fecha = Get-Date
$linea = "$fecha - $resultado"
$linea | Out-File -FilePath "C:\mantenimiento.log" -Append
```
```Bash
#!/bin/bash

service="apache2"
mail_to="admin@midominio.com"   # Cambia esto por tu correo

if ! systemctl is-active --quiet "$service"; then
    systemctl restart "$service"

    mensaje="$(date): Reinicio de $service en $(hostname)"

    echo "$mensaje" >> /var/log/mantenimiento.log

    echo "$mensaje" | mail -s "Reinicio automático de $service" "$mail_to"
fi

```
- Copias de seguridad
```PowerShell
# Actividad: Programación de backups automáticos en Windows con PowerShell
# Este script:
#  - Comprime C:\Users en un ZIP con la fecha en el nombre
#  - Guarda el backup en D:\backups
#  - Añade una entrada a un archivo de log
#  - BONUS: Verifica con Test-Path y envía correo si el backup falla

# Carpeta de origen que se va a comprimir
$Origen  = "C:\Users"

# Carpeta de destino donde se guardarán los backups
$Destino = "D:\backups"

# Crear la carpeta de destino si no existe (Test-Path + New-Item)
if (-not (Test-Path $Destino)) {
    New-Item -ItemType Directory -Path $Destino | Out-Null
}

# Fecha en formato YYYY-MM-DD para el nombre del ZIP
$Fecha = Get-Date -Format "yyyy-MM-dd"

# Ruta completa del archivo ZIP de backup
$Zip   = Join-Path $Destino "backup-$Fecha.zip"

# Archivo de log donde se registran los resultados
$Log   = Join-Path $Destino "backup_diario.log"

# Configuración básica de correo (adaptar a cada entorno)
# Estos datos son de ejemplo y deben cambiarse por valores reales
$MailTo     = "admin@midominio.com"      # Destinatario del correo
$MailFrom   = "backup@midominio.com"     # Remitente del correo
$SmtpServer = "smtp.midominio.com"       # Servidor SMTP

# Comprimir la carpeta de usuarios en un ZIP (Compress-Archive)
Compress-Archive -Path $Origen -DestinationPath $Zip -Force

# Verificar con Test-Path si el fichero de backup se ha creado correctamente
if (Test-Path $Zip) {
    # Mensaje de log en caso de éxito
    $Mensaje = "$(Get-Date): Backup correcto en $Zip"
} else {
    # Mensaje de log en caso de error
    $Mensaje = "$(Get-Date): ERROR: no se ha creado el backup en $Zip"

    # BONUS: Enviar notificación por correo si el backup falla
    try {
        Send-MailMessage -To $MailTo -From $MailFrom -Subject "ERROR en backup diario" `
            -Body $Mensaje -SmtpServer $SmtpServer
    } catch {
        # Si falla el envío de correo, añadir también el error al log
        $Mensaje += " (además, error al enviar correo: $($_.Exception.Message))"
    }
}

# Escribir el mensaje (éxito o error) en el archivo de log
$Mensaje | Out-File -FilePath $Log -Append

# Ejemplo de programación en el Programador de tareas (Task Scheduler):
#  - Acción: Iniciar un programa
#  - Programa: powershell.exe
#  - Argumentos: -File "C:\Scripts\backup_diario.ps1"
#  - Hora de ejecución diaria: 23:00
```
```Bash
#!/bin/bash
# Actividad: Programación de backups automáticos en Linux
# Este script:
#  - Comprime /etc y /home
#  - Guarda el backup en /backups con la fecha en el nombre
#  - Registra el resultado en un archivo de log

# Directorio donde se guardan los backups
BACKUP_DIR="/backups"

# Archivo de log donde se registran los resultados
LOG="/var/log/backup_diario.log"

# Fecha en formato YYYY-MM-DD
FECHA=$(date +%F)

# Nombre del archivo de backup (tar.gz)
FICHERO="$BACKUP_DIR/backup-$FECHA.tar.gz"

# Crear la carpeta de backups si no existe
mkdir -p "$BACKUP_DIR"

# Comprimir /etc y /home en un solo fichero tar.gz
tar -czf "$FICHERO" /etc /home

# Comprobar si el comando anterior ha ido bien (código de salida 0 = OK)
if [ $? -eq 0 ]; then
    # Línea de log en caso de éxito
    echo "$(date): Backup correcto en $FICHERO" >> "$LOG"
else
    # Línea de log en caso de error
    echo "$(date): ERROR al crear el backup" >> "$LOG"
fi

# Ejemplo de línea de cron (para pegar en crontab de root con 'crontab -e'):
# 0 23 * * * /usr/local/sbin/backup_diario.sh
```
- Monitorizar VM
```PowerShell
# Hyper-V: detectar máquinas detenidas y mostrar una "alerta" simple
$stoppedVMs = Get-VM | Where-Object State -eq 'Off'

if ($stoppedVMs) {
    $stoppedVMs | ForEach-Object {
        Write-Warning "La VM de Hyper-V '$($_.Name)' está detenida."
    }

    # Aquí podrías añadir:
    # - Enviar un correo
    # - Escribir en el Visor de eventos
    # - Lanzar un popup, etc.
}
```
```PowerShell
# VirtualBox
$vboxmanage = "$env:ProgramFiles\Oracle\VirtualBox\VBoxManage.exe"
if (-not (Test-Path $vboxmanage)) {
    Write-Error "No se ha encontrado VBoxManage en $vboxmanage"
    return
}
```
- Azure
  - https://www.jesusninoc.com/06/28/instalacion-de-azure-powershell-en-windows-mediante-install-module/
  - https://www.jesusninoc.com/06/29/crea-un-nuevo-usuario-de-active-directory-en-azure/
  - https://www.jesusninoc.com/06/28/crear-una-maquina-virtual-con-un-windows-server-en-azure-desde-powershell/
  - https://www.jesusninoc.com/06/28/crear-una-maquina-virtual-en-azure-con-un-windows-server-y-un-internet-information-services-iis-desde-powershell/
  - https://www.jesusninoc.com/01/12/reconocer-emociones-de-las-caras-de-las-personas-que-hay-en-una-imagen-con-emotion-api-de-microsoft-azure/

```PowerShell
# Variables for common values
$resourceGroup = "myResourceGroup"
$location = "westeurope"
$vmName = "myVM"

# Create user object
$cred = Get-Credential -Message "Usuario y password para la máquina virtual"

# Simular creación del grupo de recursos (no lo crea)
New-AzResourceGroup -Name $resourceGroup -Location $location -WhatIf

# Simular creación de la máquina virtual y recursos asociados
New-AzVM `
  -ResourceGroupName $resourceGroup `
  -Name $vmName `
  -Location $location `
  -ImageName "Win2016Datacenter" `
  -VirtualNetworkName "myVnet" `
  -SubnetName "mySubnet" `
  -SecurityGroupName "myNetworkSecurityGroup" `
  -PublicIpAddressName "myPublicIp" `
  -Credential $cred `
  -OpenPorts 80 `
  -WhatIf
```
- Usar AWS CLI
```Bash
#!/bin/bash

# ID de la instancia EC2 a monitorizar
INSTANCE_ID="i-0edbc195ff828707f"

# Comprobar estado de la instancia EC2
estado=$(aws ec2 describe-instance-status \
  --instance-ids "$INSTANCE_ID" \
  --query 'InstanceStatuses[0].InstanceState.Name' \
  --output text 2>/dev/null)

# Si no está "running", escribimos en log e intentamos arrancarla
if [ "$estado" != "running" ]; then
  echo "$(date '+%Y-%m-%d %H:%M:%S'): Instancia $INSTANCE_ID no disponible (estado: $estado). Reiniciando..." >> /var/log/aws_monitor.log
  aws ec2 start-instances --instance-ids "$INSTANCE_ID" >> /var/log/aws_monitor.log 2>&1
else
  # Si está en running, lo mostramos por pantalla
  echo "$(date '+%Y-%m-%d %H:%M:%S'): La instancia $INSTANCE_ID está arrancada (estado: $estado)."
fi
```
- Configura AWS CLI y Azure CLI (script de simulación)
```Bash
#!/bin/bash

LOG_FILE="multi_cloud_monitor.log"
NOW=$(date +"%Y-%m-%d %H:%M:%S")

########################################
# 0) Crear ficheros mock si no existen
########################################

if [ ! -f aws_ec2_mock.txt ]; then
  cat << 'EOF' > aws_ec2_mock.txt
i-11111111111111111 running
i-22222222222222222 stopped
i-33333333333333333 running
EOF
fi

if [ ! -f azure_vm_mock.txt ]; then
  cat << 'EOF' > azure_vm_mock.txt
vm-lab-1    VM running
vm-lab-2    VM stopped
vm-lab-3    VM deallocated
EOF
fi

echo "[$NOW] ---- Nueva ejecución ----" >> "$LOG_FILE"

########################################
# 1) AWS – EC2
########################################

AWS_OUTPUT=""
AWS_SOURCE="none"

if command -v aws >/dev/null 2>&1; then
  # Intento real con AWS CLI
  AWS_OUTPUT=$(aws ec2 describe-instances \
    --query "Reservations[].Instances[].{Id:InstanceId,State:State.Name}" \
    --output text 2>/dev/null)

  if [ $? -ne 0 ] || [ -z "$AWS_OUTPUT" ]; then
    # Sin permisos, sin cuenta o sin instancias: usar mock
    AWS_OUTPUT=$(cat aws_ec2_mock.txt)
    AWS_SOURCE="mock"
  else
    AWS_SOURCE="cli"
  fi
else
  # AWS CLI no está instalado: usar mock
  AWS_OUTPUT=$(cat aws_ec2_mock.txt)
  AWS_SOURCE="mock-cli-not-found"
fi

if [ "$AWS_SOURCE" != "none" ]; then
  # Contar instancias running y detenidas (stopped/terminadas)
  RUNNING_AWS=$(echo "$AWS_OUTPUT" | awk '$2 ~ /running/i {c++} END {print c+0}')
  STOPPED_AWS=$(echo "$AWS_OUTPUT" | awk '$2 ~ /stopped|terminated|shutting-down/i {c++} END {print c+0}')

  echo "[$NOW] AWS ($AWS_SOURCE) - Instancias running: $RUNNING_AWS, stopped/otras: $STOPPED_AWS" | tee -a "$LOG_FILE"

  # Registrar detalle
  echo "$AWS_OUTPUT" | awk -v ts="$NOW" '{printf "[%s] AWS - %s %s\n", ts, $1, $2}' >> "$LOG_FILE"
else
  echo "[$NOW] AWS - No se ha podido obtener información (ni CLI ni mock)" | tee -a "$LOG_FILE"
fi

########################################
# 2) Azure – VMs
########################################

AZ_OUTPUT=""
AZ_SOURCE="none"

if command -v az >/dev/null 2>&1; then
  # Intento real con Azure CLI
  AZ_OUTPUT=$(az vm list -d \
    --query "[].{Name:name,PowerState:powerState}" \
    --output tsv 2>/dev/null)

  if [ $? -ne 0 ] || [ -z "$AZ_OUTPUT" ]; then
    # Sin login, sin suscripción o sin VMs: usar mock
    AZ_OUTPUT=$(cat azure_vm_mock.txt)
    AZ_SOURCE="mock"
  else
    AZ_SOURCE="cli"
  fi
else
  # Azure CLI no está instalado: usar mock
  AZ_OUTPUT=$(cat azure_vm_mock.txt)
  AZ_SOURCE="mock-cli-not-found"
fi

if [ "$AZ_SOURCE" != "none" ]; then
  # Contar VMs activas y detenidas usando toda la línea (porque "VM running" son dos palabras)
  RUNNING_AZ=$(echo "$AZ_OUTPUT" | awk '$0 ~ /running/i {c++} END {print c+0}')
  STOPPED_AZ=$(echo "$AZ_OUTPUT" | awk '$0 ~ /stopped|deallocated/i {c++} END {print c+0}')

  echo "[$NOW] Azure ($AZ_SOURCE) - VMs running: $RUNNING_AZ, stopped/deallocated: $STOPPED_AZ" | tee -a "$LOG_FILE"

  # Registrar detalle por VM (primera columna = nombre, resto = estado)
  echo "$AZ_OUTPUT" | awk -v ts="$NOW" '{
    name = $1
    $1 = ""
    # $0 ahora contiene el estado con espacios: " VM running", etc.
    gsub(/^ +/, "", $0)
    printf "[%s] Azure - %s %s\n", ts, name, $0
  }' >> "$LOG_FILE"
else
  echo "[$NOW] Azure - No se ha podido obtener información (ni CLI ni mock)" | tee -a "$LOG_FILE"
fi

echo "[$NOW] ---- Fin de ejecución ----" >> "$LOG_FILE"
```
- Optimización de scripts
```Bash
nano monitor_servicios.sh
chmod 700 monitor_servicios.sh
sudo cat /var/log/monitor_servicios/monitor_servicios_$(date +%Y%m%d).log
# shellcheck
sudo apt-get update
sudo apt-get install -y shellcheck
shellcheck monitor_servicios.sh
```
```Bash
#!/bin/bash
# ---------------------------------------------------------
# Script : monitor_servicios.sh
# Propósito : Comprobar el estado de varios servicios,
#             generar un log y reiniciar los que fallen.
# Autor : (pon aquí tu nombre o "Alumno")
# Fecha : 2025-12-08
# ---------------------------------------------------------

# Ruta absoluta del directorio de logs
LOG_DIR="/var/log/monitor_servicios"
LOG_FILE="$LOG_DIR/monitor_servicios_$(/bin/date +%Y%m%d).log"

# Servicios a comprobar (cambiar por servicios reales del sistema)
SERVICIOS=("ssh" "cron" "apache2")

# Crear directorio de logs si no existe, con permisos restrictivos
if [ ! -d "$LOG_DIR" ]; then
  /bin/mkdir -p "$LOG_DIR"
  /bin/chmod 700 "$LOG_DIR"
fi

# Recorremos la lista de servicios
for servicio in "${SERVICIOS[@]}"; do
  FECHA=$(/bin/date "+%Y-%m-%d %H:%M:%S")
  ESTADO=$(/bin/systemctl is-active "$servicio" 2>/dev/null)

  if [ "$ESTADO" = "active" ]; then
    NIVEL="OK"
    MENSAJE="Servicio $servicio activo"
    echo "[$FECHA] [$NIVEL] $MENSAJE" >> "$LOG_FILE"
  elif [ -z "$ESTADO" ]; then
    NIVEL="UNKNOWN"
    MENSAJE="Servicio $servicio no existe o no está gestionado por systemd"
    echo "[$FECHA] [$NIVEL] $MENSAJE" >> "$LOG_FILE"
  else
    NIVEL="ERROR"
    MENSAJE="Servicio $servicio en estado '$ESTADO'. Intentando reinicio..."
    echo "[$FECHA] [$NIVEL] $MENSAJE" >> "$LOG_FILE"

    # Intentamos reiniciar el servicio
    /bin/systemctl restart "$servicio" 2>/dev/null
    NUEVO_ESTADO=$(/bin/systemctl is-active "$servicio" 2>/dev/null)
    FECHA=$(/bin/date "+%Y-%m-%d %H:%M:%S")

    if [ "$NUEVO_ESTADO" = "active" ]; then
      NIVEL="OK"
      MENSAJE="Servicio $servicio reiniciado correctamente"
    else
      NIVEL="CRITICAL"
      MENSAJE="No se pudo reiniciar el servicio $servicio (estado: '$NUEVO_ESTADO')"
    fi

    echo "[$FECHA] [$NIVEL] $MENSAJE" >> "$LOG_FILE"
  fi
done

exit 0
```
